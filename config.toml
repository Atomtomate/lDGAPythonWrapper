[general]
runDir = "/scratch/projects/hhp00048/PD_test/data_20_20_s0/beta{beta}_U{U}"
codeDir = "/scratch/projects/hhp00048/codes"
CFLAGS = "-O3 -xHost"
verbose = false
cluster = "berlin"
custom_slurm_lines = "-A hhp00048"
custom_init_andpar_file = "/scratch/usr/hhpstobb/old_work/lDGA/data/b15.0_U2.0/data/hubb.andpar"
custom_init_andpar_vals_only = true
custom_module_load = "module restore ed"
custom_conda_env = "p3"
auto_continue = true
restart_after_success = true   # do not attempt to restart already completed jobs

[parameters]
beta = 25
U = 1.0
mu = "HF"
ns = 5
bethe = false
Dimensions = 3
symm = true

[ED]
skip = false
w_min = -12.0       # unwichtig
w_max = 12.0        # unwichtig
deltino = 0.01      # unwichtig
imaxmu = 0          # unwichtig        
deltamu = 0.0       # unwichtig
iterations = 80
conv_param = "1.d-13"
# thresholds for anderson parameters checks
square_sum_diff = 1.0      # maximal allowed value for sum_k (eps^2_k - tpar^2_k)
bathsite_cancel_eps = 0.01 # minimal allowed value for |eps_k - eps_l| 
bathsite_cancel_V = 0.01   # minimal allowed value for |V_l|
large_eps = 10             # maximal factor c for |eps_k| = c * T
check_behavior = "break"   # possible options: ignore (continue on check fail), warn (warn in run.err), break (fail job)


[Vertex]
skip = false
# freqList can be either a path to a frequency list or
# "F1:F2,B1:B2" for N1 to N2 (integer) fermionic and B1 to B2 bosonic.
freqList = "/scratch/projects/hhp00048/grids/b20_f20_s0/freqList.dat"
nprocs = 960

[Susc]
skip = true
nmpara = 30
nBoseFreq = 10000

[Trilex]
skip = true
nmpara = 30
nFermiFreq = 41
nBoseFreq = 40

[Postprocess]
skip = false
keep_only_data = false
data_bakup = "cp"
output_format = "tar,text"
split = true

[lDGA]
LQ = 4          # FFT requires: 2 * LQ - 2 == Nint
Nint = 4        # 
k_range = 4     # Sigma FFT requires: k_range = LQ - 1
only_chisp_ch = false
only_lambda_sp = true
only_positive_ch = true
only_positive_sp = true
kInt = "FFT" # possible values are naive, gl-n (n being the order of the Gauss Legendre integration) or FFT

[lDGAFortran]
skip = true

[lDGAJulia]
skip = false
nprocs = 96
outfile   = "lDGA_out_sp_40"
Nk        = 40                          # IMPORTANT: in Fortran this is Nk x Nk and generated bei make_klist. TODO: adaptiv mesh
tail_correction = "Nothing"             #"Richardson" # Nothing, Richardson, Shanks
lambda_correction = "sp"                # nothing, sp, sp_ch
bosonic_sum = "common"                  # common (intersection of individual ranges), individual (max range in each channel; fortran def    ault), full (all frequencies), fixed:N:M (always sum from N to (including) M, indexing starts at 0)
force_full_bosonic_chi = false          # compute all omega frequencies for chi and trilex
chi_unusable_fill_value = "chi_lambda"  # can be "0", "chi_lambda" or "chi". sets either 0, lambda corrected or non lambda corrected values outside usable omega range
chi_only = false                        # Should only chis_omega and chich_omega be calculated?
rhs  = "native"                         # TODO: implement possible modes: native (fixed for tc, error_comp for naive), 
                          #                                 fixed (n/2 (1 - n/2) - sum(chi_ch)), 
                          #                                 error_comp (chi_loc_ch + chi_loc_sp - chi_ch)
fermionic_tail_coeffs = [0,1,2,3,4,5,6]
bosonic_tail_coeffs = [0,1,2,3,4]
usable_prct_reduction = 0.1

[lDGAPost]
delete_calc = false # WARNING: this will delete all logfiles and intermediate results such as F and chi
result_vars = "chi_q"
